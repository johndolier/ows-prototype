<template>
  <div class="h-full w-full mx-1 ">
    <div class="w-full my-2">
      <PButton class="inline-flex mx-2 left-button" severity="info" size="small" label="Show Geotweets"
        @click="requestGeotweets">
      </PButton>
      <PButton class="mx-5 w-2 right-button" severity="danger" size="small" label="Clear all" 
        @click="clearAllLayers">
      </PButton>
    </div>
    <div id="mapContainer" class="">
    </div>
  </div>
</template>


<script>

import "leaflet/dist/leaflet.css";
import L from "leaflet";
import 'leaflet-draw/dist/leaflet.draw.css';

import { useScriptTag } from '@vueuse/core';
useScriptTag('leaflet-heat.js');

require('leaflet-draw');

import { v4 as get_uid } from 'uuid';

export default {

  name: "MapComponent",
  props: {
    documents: Object, // object that holds all documents that should eventually be displayed in the Map component
    stacItems: Object, // object that holds all stac items that have been queried + meta data if it should be displayed etc...
    initialLocationFilters: Object, // list of location filters from HomeView component (used for initializing map)
  },
  inject: ['Utils'],
  emits: [
    'addLocationFilter', // adds a location filter object to locationFilterList in HomeView component
    'clearAllLocationFilters',  // clears the locationFilterList
    'requestGeotweets',   // triggers request to backend to retrieve geotweets (example)
    'updateLocationFilterList',   // (id, geoBounds): with those two attributes, creates locationFilter object and adds it to locationFilterList 
    'focusMapOnLocationFilters' // triggers iteration over locationFilterList and focuses map on dynamic center of filters
  ], 
  components: {},

  data() {
    return {
      map: null,
      // map layers
      stacCollectionLayers: [],
      // draw controller
      drawControl: null,
      // polygonDrawer: null,
      drawnLayers: null, 
    }
  },

  computed: {
    mapDocuments() {
      return null;
    }, 
  },

  methods: {
    // interactive map methods
    addLocationFilterLayer(geoBounds) {
      // creates a Layer from the specified geoBounds and adds it to the drawnLayers FeatureGroup
      // used for new Layers that were not generated by drawing on the map (e.g. from geoparsing in backend)
      const layer = this.createLayerFromGeoBounds(geoBounds);
      this.drawnLayers.addLayer(layer);
      return layer;
    }, 
    removeFilterLayer(layer) {
      // TODO check if layer is present in map?
      this.map.removeLayer(layer);
    }, 
    clearSTACLayers() {
      for (const layer of this.stacCollectionLayers) {
        this.map.removeLayer(layer);
      }
    }, 
    clearAllLayers() {
      // loops over all layers (stac items and filter area) and removes them from map
      // remove filter areas
      this.$emit('clearAllLocationFilters');
      for (const layer of this.drawnLayers.getLayers()) {
        this.map.removeLayer(layer);
      }
      this.drawnLayers.clearLayers();

      // remove STAC layers
      // TODO think of better way to store stac items and layers
      this.clearSTACLayers();
      this.stacCollectionLayers = [];
    }, 
    getBoundsFromBBox(bbox) {
      return new L.LatLngBounds([bbox[0], bbox[1]], [bbox[2], bbox[3]]);
    }, 
    createLayerFromGeoBounds(geoBounds) {
      // takes some form of geoBounds object and transforms it into Leaflet Layer form
      // types: bbox, bounds, Polygon

      const color = '#ff7800';
      if (geoBounds.type == "bbox") {
        // bbox is [south, west, north, east] 
        const bounds = this.getBoundsFromBBox(geoBounds.coords);
        const layer = new L.rectangle(bounds, {color: color});
        return layer;
      }
      else if (geoBounds.type == 'bounds') {
        const layer = new L.rectangle(geoBounds.coords, {color: color});
        return layer;
      }
      else if (geoBounds.type == 'polygon') {
        // TODO
        const layer = new L.Polygon(geoBounds.coords, {color: color});
        return layer;
      }
      // TODO implement other shapes
      console.log("warning - createLayerFromGeoInformation: unknown type (" + geoBounds.type + ")");
    }, 
    focusMap(geoBoundsList) {
      // focus map by using the center of the geobounds list

      let initialBounds = null;
      for (const geoBounds of geoBoundsList) {
        // convert 
        let currentBounds = null;
        if (geoBounds.type == 'bbox') {
          currentBounds = this.getBoundsFromBBox(geoBounds.coords);
        }
        else {
          // TODO handle other bound types
          console.log("not implemented (focusMap");
          continue;
        }
        if (initialBounds == null) {
          initialBounds = currentBounds;
        }
        else {
          //console.log(initialBounds);
          initialBounds = initialBounds.extend(currentBounds);
        }
      }
      if (initialBounds == null) {
        console.log("warning - could not compute geoBounds for geoBoundsList; focusMap failed");
        console.log(geoBoundsList);
        return;
      }
      //console.log(initialBounds);

      this.map.fitBounds(initialBounds);
    }, 
    requestGeotweets() {
      // example function to show geotweets (used for testing!)
      this.$emit('requestGeotweets');
    }, 
    showGeotweets(geotweets) {

      // display geotweets
      // var geojsonLayer = L.geoJSON().addTo(this.map);
      let tweetLatLongList = [];
      for (const tweet of geotweets) {
        // geojsonLayer.addData(tweet);
        tweetLatLongList.push(tweet.geometry.coordinates);
      }
      this.addHeatMap(tweetLatLongList);
    }, 

    addHeatMap(coordinateList) {
      // adds the coordinate list as a heatmap on the map
      // TODO handle data structure (for later editing)

      // add intensity as third parameter in list
      // TODO use some (meaningful) weight for intensity?
      let intensityList = [];
      for (const coordinates of coordinateList) {
        const intensity = [coordinates[0], coordinates[1], 0.5];
        intensityList.push(intensity);
      }
      L.heatLayer(
        intensityList, 
        {
          maxZoom: 3,
          radius: 12, 
          //gradient: {0.4: 'blue', 0.65: 'lime', 1: 'red'}, 
          minOpacity: 0.3, 
        }
        ).addTo(this.map);
    }
  },

  watch: {
    stacItems: {
      handler() {
        this.clearSTACLayers();
        for (const [stac_collection_id, entryList] of Object.entries(this.stacItems)) {
          for (const entry of entryList) {
            if (!entry.selected) {
              continue;
            }
            // create layer for each entry
            const newFeatureGroup = new L.FeatureGroup();
            const color = this.Utils.stringToColour(stac_collection_id);
            for (const stac_item of entry.stac_items) {
              newFeatureGroup.addLayer(L.geoJSON(stac_item));
            }
            newFeatureGroup.setStyle(
              function() {
                return {color: color}
              }
            );
            this.stacCollectionLayers.push(newFeatureGroup);
            newFeatureGroup.addTo(this.map);  
          }
        } 
      }, 
      deep: true, 
    }, 
  }, 

  mounted() {
    // build map
    this.map = L.map("mapContainer", { 
      drawControl: false, 
      minZoom: 3, 
      maxZoom: 10,
    }).setView([45, 20], 5);

    L.tileLayer("http://{s}.tile.osm.org/{z}/{x}/{y}.png", {
      attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors',
    }).addTo(this.map);

    // enable drawing shapes on map
    // FeatureGroup is to store editable layers
    this.drawnLayers = new L.FeatureGroup();
    this.map.addLayer(this.drawnLayers);
    this.drawControl = new L.Control.Draw({
      position: 'topright', 
      draw: {
        polygon: true, 
        polyline: false, 
        circle: false, 
        rectangle: true, 
        marker: false, 
        circlemarker: false, 
      }, 
      edit: {
        featureGroup: this.drawnLayers
      }
    });
    this.map.addControl(this.drawControl);
    // create polygon drawer
    this.map.on('draw:created', e => {
      // TODO enable polygon (currently just bbox is allowed)
      e.layer.setStyle({
        color: 'red', 
      });
      
      // handle different shapes (rectangle, polygon)
      let geoBounds = null;
      if (e.layerType == 'rectangle') {
        // we convert rectangle bounds to bbox and store it into coordinates
        const coords = this.Utils.getBBoxFromBounds(e.layer.getBounds())
        geoBounds = {
        'type': 'bbox', 
        'coords': coords, 
        'drawn': true, 
        };
      } else if (e.layerType == 'polygon') {
        // polygon coords are simply the LatLng lists of the layer
        geoBounds = {
        'type': 'polygon', 
        'coords':  e.layer.getLatLngs(), 
        'drawn': true, 
        };
      } else {
        console.log("warning - unknown layer type: " + e.layerType + "; cannot create drawn layer :(");
        return
      }
      this.drawnLayers.addLayer(e.layer);
      this.$emit('addLocationFilter', get_uid(), geoBounds, true);
    });

    // add layers from location filters that have been queued up by now
    let idx = 0;
    for (const filterObj of this.initialLocationFilters) {
      if (filterObj.layer == null) {
        // layer was not created before
        const layer = this.addLocationFilterLayer(filterObj.geoBounds);
        this.$emit('updateLocationFilterList', idx, layer);
      }
      idx += 1;
    }

    // focus map at the beginning
    this.$emit('focusMapOnLocationFilters');

  },

  onBeforeUnmount() {
    if (this.map) {
      this.map.remove();
    }
  },
};

</script>
